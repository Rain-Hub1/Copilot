name: Processar Mensagem de Chat com IA

on:
  workflow_dispatch:
    inputs:
      chatId:
        description: 'ID do Chat no Firestore'
        required: true

jobs:
  processar:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm install @google/generative-ai octokit @firebase/app @firebase/firestore
      
      - name: Executar Script de Chat da IA
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          node -e '
            const { GoogleGenerativeAI } = require("@google/generative-ai");
            const { Octokit } = require("octokit");
            const { initializeApp } = require("@firebase/app");
            const { getFirestore, collection, getDocs, addDoc, query, orderBy, serverTimestamp } = require("@firebase/firestore");

            const firebaseConfig = {
              apiKey: "AIzaSyC0JUKA-uIHMpxLRtv7BwraOph3QOamxhA",
              authDomain: "github-ai-a4fcb.firebaseapp.com",
              projectId: "github-ai-a4fcb",
              storageBucket: "github-ai-a4fcb.firebasestorage.app",
              messagingSenderId: "99989504065",
              appId: "1:99989504065:web:fa916d2c5f69d44f9006c0"
            };
            
            const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);

            function parseCommand(message) {
                const createRegex = /crie o arquivo (.+?) no repo (.+?) com o conteúdo \'(.+)\'/i;
                const editRegex = /edite o arquivo (.+?) no repo (.+?) para ter o conteúdo \'(.+)\'/i;
                const readRegex = /leia o arquivo (.+?) do repo (.+)/i;

                let match = message.match(createRegex);
                if (match) return { command: "create", path: match[1], repo: match[2], content: match[3] };
                
                match = message.match(editRegex);
                if (match) return { command: "edit", path: match[1], repo: match[2], content: match[3] };

                match = message.match(readRegex);
                if (match) return { command: "read", path: match[1], repo: match[2] };

                return null;
            }

            async function run() {
              const chatId = "${{ github.event.inputs.chatId }}";
              const messagesRef = collection(db, "chats", chatId, "messages");
              
              try {
                const q = query(messagesRef, orderBy("timestamp"));
                const querySnapshot = await getDocs(q);
                const messages = querySnapshot.docs.map(doc => doc.data());

                if (messages.length === 0) return;
                const lastUserMessage = messages[messages.length - 1];
                if (lastUserMessage.role !== "user") return;

                const command = parseCommand(lastUserMessage.content);
                let commandResponse = "";

                if (command) {
                    const owner = "Rain-Hub1";
                    const contentEncoded = Buffer.from(command.content || "").toString("base64");

                    if (command.command === "create") {
                        await octokit.repos.createOrUpdateFileContents({ owner, repo: command.repo, path: command.path, message: `IA: cria ${command.path}`, content: contentEncoded });
                        commandResponse = `Arquivo ${command.path} criado com sucesso no repositório ${command.repo}.`;
                    } else if (command.command === "edit") {
                        const { data: file } = await octokit.repos.getContents({ owner, repo: command.repo, path: command.path });
                        await octokit.repos.createOrUpdateFileContents({ owner, repo: command.repo, path: command.path, message: `IA: edita ${command.path}`, content: contentEncoded, sha: file.sha });
                        commandResponse = `Arquivo ${command.path} editado com sucesso no repositório ${command.repo}.`;
                    } else if (command.command === "read") {
                        const { data: file } = await octokit.repos.getContents({ owner, repo: command.repo, path: command.path });
                        const decodedContent = Buffer.from(file.content, "base64").toString("utf-8");
                        commandResponse = `Conteúdo de ${command.path}:\n\n---\n${decodedContent}\n---`;
                    }
                }

                if (commandResponse) {
                    await addDoc(messagesRef, { role: "assistant", content: commandResponse, timestamp: serverTimestamp() });
                } else {
                    const history = messages.map(msg => ({ role: msg.role, parts: [{ text: msg.content }] }));
                    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
                    const chat = model.startChat({ history });
                    const result = await chat.sendMessage(lastUserMessage.content);
                    await addDoc(messagesRef, { role: "assistant", content: result.response.text(), timestamp: serverTimestamp() });
                }
              } catch (error) {
                await addDoc(messagesRef, { role: "assistant", content: `Desculpe, ocorreu um erro: ${error.message}`, timestamp: serverTimestamp() });
              }
            }
            run();
          '
